[P1433 吃奶酪 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1433)

## 题目描述

房间里放着 $n$ 块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 $(0,0)$ 点处。

## 输入格式

第一行有一个整数，表示奶酪的数量 $n$。

第 $2$ 到第 $(n + 1)$ 行，每行两个实数，第 $(i + 1)$ 行的实数分别表示第 $i$ 块奶酪的横纵坐标 $x_i, y_i$。

## 输出格式

输出一行一个实数，表示要跑的最少距离，保留 $2$ 位小数。

## 样例 #1

### 样例输入 #1

```
4
1 1
1 -1
-1 1
-1 -1
```

### 样例输出 #1

```
7.41
```

## 提示

#### 数据规模与约定

对于全部的测试点，保证 $1\leq n\leq 15$，$|x_i|, |y_i| \leq 200$，小数点后最多有 $3$ 位数字。

#### 提示

对于两个点 $(x_1,y_1)$，$(x_2, y_2)$，两点之间的距离公式为 $\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$。

---

$2022.7.13$：新增加一组 $\text{Hack}$ 数据。


## 题解

#DFS #剪枝 #状态压缩 #位运算 

### 方法一

采用暴力DFS直接全排列， 由于每一个坐标的位置固定，影响到最短路的因素只有每个点的访问次序。
但是全排列的问题实在是太难处理的，目前依然属于NP问题，虽然这个题目的测试数据很小，但是依然会 达到15！，这时候必须采取剪枝策略，可是即便如此，当碰到非常恶劣的数据的时候，DFS依然会TLE。下面这个代码能过大部分测试点，只有一个过不了。
![[Pasted image 20241015082706.png]]
```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<math.h>

using namespace std;
const int N = 20;
int n;
double x[N], y[N];
bool st[N];//st[i] == true 表示第i个点已经被占用
double minsum;//存储最小距离

//计算两点之间的距离
double distance(double x1, double y1, double x2, double y2)
{
	double res = 0.0;

	res = sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));

	return res;
}

//1. DFS搜索+剪枝
//index：层数   sum:当前状态下路径上点的和 ii上一个点的序号
void dfs(int index, double sum, int ii)
{
	//剪枝
	if (sum > minsum) return;

	//递归出口
	if (index == n + 1)//1~n为操作 第n+1层要开始回溯了
	{
		//更新最小值
		if (sum < minsum)
		{
			minsum = sum;
			return;
		}
	}

	//枚举，递归到下一层
	for (int i = 1; i <= n; i++)
	{
		if (st[i] == false)
		{
			//先算距离
			double dou = distance(x[ii], y[ii], x[i], y[i]);

			st[i] = true;
			dfs(index + 1, sum + dou, i);
			st[i] = false;//回复现场
		}
	}

}

int main()
{
	//scanf("%d", &n);
	cin >> n;
	for (int i = 1; i <= n; i++)
		//scanf("%f%f", &x[i], &y[i]);
		cin >> x[i] >> y[i];

	x[0] = 0; y[0] = 0;
	minsum = 0x3f3f3f3f;

	//路径上上一个点是0号点， 0—>1
	dfs(1, 0.0, 0);//从第一个奶酪开始递归

	printf("%.2lf", minsum);

	return 0;
}
```


### 方法二

这个题目的正确解法应该是状态压缩DP+位运算。