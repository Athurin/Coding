
链接：[https://ac.nowcoder.com/acm/contest/66433/C](https://ac.nowcoder.com/acm/contest/66433/C)
## 题目描述

```
    在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。

    面对海量租借教室的信息，我们自然希望编程解决这个问题。

    我们需要处理接下来n天的借教室信息，其中第i天学校有ri个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为dj, sj, tj，表示某租借者需要从第sj天到第tj天租借教室（包括第sj天和第tj天），每天需要租借dj个教室。

    我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供dj个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。

    借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第sj天到第tj天中有至少一天剩余的教室数量不足dj个。

    现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。
```

## 输入描述:

第一行包含两个正整数`n, m` ，表示天数和订单的数量。

第二行包含 n 个正整数，其中第i个数为`ri` ，表示第i天可用于租借的教室数量。

接下来有 m 行，每行包含三个正整数`dj, sj, tj` ，表示租借的数量，租借开始、结束分别在第几天。

每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。

## 输出描述:

如果所有订单均可满足，则输出只有一行，包含一个整数0。否则（订单无法完全满足）输出两行，第一行输出一个负整数-1，第二行输出需要修改订单的申请人编号。

## 示例

输入
```
4 3
2 5 4 3
2 1 3
3 2 4
4 2 4
```

输出
```
-1
2
```

说明
```
第1 份订单满足后，4 天剩余的教室数分别为0，3，2，3。  
第2 份订单要求第2 天到第4 天每天提供3 个教室，而第3 天剩余的教室数为2，因此无法满足。分配停止，通知第2个申请人修改订单。
```

备注
$$
\displaylines{

对于10\%的数据，有1≤n,m≤10；\\

对于30\%的数据，有1≤n,m≤1000；\\

对于70\%的数据，有1≤n,m≤105； \\

对于100\%的数据，有1≤n, m≤106, 0≤r_i, d_j≤109, 1≤s_j≤t_j≤ n。\\
}
$$

## 题解

#二分 #二分答案 #前缀和 #差分


```cpp
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;
const int N = 1e6+10;
long long a[N], b[N];A
long long d[N], s[N], t[N];
int n, m;

int check(int mid)//检查 mid 编号的订单是否可以满足
{
    for(int i = 1; i<=n; i++) b[i] = a[i];//b[]是差分数组
    
    for(int i=1; i<=mid; i++)//mid 编号的订单都满足一遍
    {
        b[s[i]] -= d[i];
        b[t[i] +1] += d[i];
    }
	//结算剩下的订单
    long long sum = 0;
    for(int i=1; i<=n; i++)
    {
        sum += b[i];//差分数组的和，就是第 i 天所剩下的教室数量
        if(sum < 0) return 1;//mid 编号无法满足，返回1表示找到了
    }
    
    return 0;
}

int main()
{
    cin>>n>>m;
    
    for(int i=1; i<=n; i++) scanf("%d", a+i);
    for(int i=n; i>=1; i--) a[i] -= a[i-1];
    //可用于租借的教室数量的差分数组，便于在区间内整体修改
    
    for(int i=1; i<=m; i++) scanf("%d%d%d", d+i, s+i, t+i);
    
    int l = 1, r = m;//寻找所有订单中，不可以满足的订单
    while(l < r)
    {
        int mid = l+r>>1;
        if(check(mid)) r = mid;
        else l = mid+1;
    }
    
    if(check(l))
        cout<<"-1"<<"\n"<<l;
    else cout<<"0";
    
    
    return 0;
}
```