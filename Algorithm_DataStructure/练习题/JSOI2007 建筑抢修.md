
[原题链接](https://www.luogu.com.cn/problem/P4053?contestId=141295)

## 题目描述

小刚在玩 JSOI 提供的一个称之为“建筑抢修”的电脑游戏：经过了一场激烈的战斗，T 部落消灭了所有 Z 部落的入侵者。但是 T 部落的基地里已经有 $N$ 个建筑设施受到了严重的损伤，如果不尽快修复的话，这些建筑设施将会完全毁坏。现在的情况是：T 部落基地里只有一个修理工人，虽然他能瞬间到达任何一个建筑，但是修复每个建筑都需要一定的时间。同时，修理工人修理完一个建筑才能修理下一个建筑，不能同时修理多个建筑。如果某个建筑在一段时间之内没有完全修理完毕，这个建筑就报废了。你的任务是帮小刚合理的制订一个修理顺序，以抢修尽可能多的建筑。

## 输入格式

第一行，一个整数 $N$。

接下来 $N$ 行，每行两个整数 $T_1,T_2$ 描述一个建筑：修理这个建筑需要 $T_1$ 秒，如果在 $T_2$ 秒之内还没有修理完成，这个建筑就报废了。

## 输出格式

输出一个整数 $S$，表示最多可以抢修 $S$ 个建筑。

## 样例 #1

### 样例输入 #1

```
4
100 200
200 1300
1000 1250
2000 3200
```

### 样例输出 #1

```
3
```

## 提示

对于 $100 \%$ 的数据，$1 \le N < 150000$，$1 \le T_1 < T_2 < 2^{31}$。

## 算法标签

#贪心 #反悔贪心 #优先队列 


## 题解

贪心思想：局部最优解决全局最优，一般的贪心只有一个峰值，但是如果有多个极值，就会干扰到最值的求解。

这时，对于某个类具有多个干扰判断的属性时，可以采用反悔贪心

AC:
```cpp
#include<iostream>
#include<algorithm>
#include<queue>

using namespace std;
typedef unsigned long long LL;
const int N = 15e4+10;

priority_queue<int, vector<int>, less<int>> q; //大根堆

struct T
{
    int a;//t1
    int b;//t2
}t[N];

//结构体的自定义排序
//按照报废时间 t2 进行排序
bool cmp(struct T& rhs, struct T& lhs)
{
    return rhs.b < lhs.b;
}

int main()
{
    int n;
    cin>>n;
    
    for(int i=1; i<=n; i++)
        scanf("%d%d", &t[i].a, &t[i].b);
    
    sort(t+1, t+n+1, cmp);
    
    LL time = 0;
    int res = 0;
    //反悔贪心
    for(int i=1; i<=n; i++)
    {
        time += t[i].a;//先加上再说
        q.push(t[i].a);
        if(time <= t[i].b) res++;
        else//发现贪心得不够多，就把抢修需要时间最多得建筑舍弃掉
        //为什么舍弃抢修需要时间最多得建筑？
        //因为在同样的时间内，单个时间约少，最后能够抢修的数量越多
        {
            time -= q.top();//反悔了，退一步
            q.pop();
        }
    }
    
    cout<<res;
    
    return 0;
}
```