## 模板题
[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)

#双指针 
### 1 暴力求解

缺点：慢，时间 `O(n^2)`
优点：不会改变相对位置

AC
```cpp
class Solution 
{
public:
    int removeElement(vector<int>& nums, int val) 
    {
        int size = nums.size();
        //第一个元素可能为val 一轮循环结束之后由-1变为1
        for(int i=0; i<size; i++)
        {
            if(nums[i] == val)
            {
                for(int j = i+1; j<size; j++)
                {
                    nums[j-1] = nums[j];
                }
                size--;
                i--;
            }
        }
        return size;
    }
};
```

### 2 快慢双指针算法

如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针**同时右移**；

如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。

整个过程保持不变的性质是：区间 `[0,slow)` 中的元素都不等于 `val`。当左右指针遍历完输入数组以后，`slow` 的值就是输出数组的长度。

时间 `O(n)` 
不会改变相对位置

```cpp
class Solution 
{
public:
    int removeElement(vector<int>& nums, int val) 
    {
        int size = nums.size();
        int slow = 0;
        for(int fast=0; fast < size; fast++)
        {
            if(nums[fast] != val)
            {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;  //[0,slow)
    }
};
```

### 3 对撞双指针法  （优化）

时间`O(n)`  确保移动最少的元素
缺点：会改变元素的相对位置

下面这钟解法，在样例`nums = [1], val = 1`时出错，虽然有效的数据长度确实为0，但是没有通过。
```cpp
class Solution 
{
public:
    int removeElement(vector<int>& nums, int val) 
    {
        int left = 0;
        int right =  nums.size()-1;
        while(left <= right)
        {
            while(nums[left] !=  val && left <= right) 
	            left++ ;
            while(nums[right] == val && left <= right) 
	            right--;
            if(left < right)
                nums[left++] = nums[right--];
        }
        return left;
    }
};
```

AC
```cpp
class Solution 
{
public:
    int removeElement(vector<int>& nums, int val) 
    {
        int left = 0;
        int right =  nums.size()-1;
        while(left <= right)
        {
            if(nums[left] != val) left++;
            else if(nums[right] == val) right--;
            else
                nums[left++] = nums[right--];
        }
        return left;
    }
};
```

## 2 [26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

==**非严格递增排列** 的数组 `nums`==

如果数组本身没有单调性，就不能这样做，可以先快排 再 快慢指针。

AC
```cpp
class Solution 
{
    //双指针算法
    //left指向有序去重部分的后的第一位
    //right指向的数即将填入nums[p]中
    //一个元素一定是有序去重的
public:
    int removeDuplicates(vector<int>& nums) 
    {
        int size =nums.size();
        if(size == 1) return size;

        int left = 1, right = 1;
        while(right < size)
        {
            if(nums[right] != nums[left-1])
                nums[left++] = nums[right]; 
                //赋值之后，nums[right-1] != nums[right];
            right++;
        }
        return left;
    }
};
```


## 3 [283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/)

保持非零元素的相对顺序

快慢指针, 需要注意把数组最后的元素还原成 0

AC
```cpp
class Solution 
{
public:
    void moveZeroes(vector<int>& nums) 
    {
        int size = nums.size();
        int slow = 0;
        for(int fast = 0; fast < size; fast++)
        {
            if(nums[fast] != 0)
            {
                nums[slow++] = nums[fast];
            }
        }
        std::fill(nums.end() - (size-slow), nums.end(), 0);
    }
};
```

## 4[844. 比较含退格的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/backspace-string-compare/)
### 1 利用栈重构字符串

非原地操作，效率低下
```cpp
class Solution 
{
public:
    //返回重构的字符串
    string rebuild(string str)
    {
        string res;
        for(int i=0; i<str.size(); i++)
        {
            if(str[i] != '#')
                res.push_back(str[i]);
            else
            {
                if(!res.empty())
                    res.pop_back();
            }
        }
        return res;
    }

    bool backspaceCompare(string s, string t) 
    {
        return rebuild(s) == rebuild(t);
    }
};
```


### 双指针算法，但是逆向

WA:
```
s = "bxj##tw"
t = "bxo#j##tw"
```
```cpp
class Solution 
{
public:
    bool backspaceCompare(string s, string t) 
    {
        //逆向
        int ps = s.size()-1;
        int pt = t.size()-1;
        int skips = 0;
        int skipt = 0;
        while(ps >= 0 && pt >= 0)
        {
            while(s[ps] == '#')
            {
                skips++;
                ps--;
            }
            ps -= skips;
            skips = 0;

            while(t[pt] == '#')
            {
                skipt++;
                pt--;
            }
            pt -= skipt;
            skipt = 0;

            //ps、pt可能为-1
            if(ps < 0 || pt < 0) continue;

            if(s[ps] == t[pt])
            {
                ps--;
                pt--;
            }
            else
                return false;
        }
        return true;
    }
};
```

AC:
```cpp
class Solution 
{
public:
    bool backspaceCompare(string s, string t) 
    {
        int ps = s.size()-1;
        int pt = t.size()-1;
        int skips = 0;
        int skipt = 0;

        while(ps >= 0 || pt >= 0)
        {
            while(ps >= 0)
            {
                if(s[ps] == '#')
                {
                    ps--;
                    skips++;
                }
                else if(skips > 0 && ps >= 0)
                {
                    skips--;
                    ps--;
                }
                else
                    break;
            }
            while(pt >= 0)
            {
                if(t[pt] == '#')
                {
                    pt--;
                    skipt++;
                }
                else if(skipt > 0 && pt >= 0)
                {
                    skipt--;
                    pt--;
                }
                else
                    break;
            }

            if(pt >= 0 && ps >= 0)
            {
                if(s[ps] != t[pt])
                    return false;
            }
            else
            {
                if(pt != ps) // 不能同时为负数
                    return false;
            }

            ps--, pt--;
        }
        return true;
    }
};
```
