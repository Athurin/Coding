
#滑动窗口
## 模板

[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

滑动窗口
时间复杂度 ：`O(n)`

AC:
```cpp
class Solution 
{
public:
    int minSubArrayLen(int target, vector<int>& nums) 
    {
        int res = INT32_MAX;
        int sum = 0;

        int i=0;
        for(int j =0; j<nums.size(); j++)
        {
            sum += nums[j];
            while(sum >= target)
            {
                int len = j - i + 1;
                res = res < len ? res : len;
                sum -= nums[i++];
            }
        }
        return res == INT32_MAX ? 0 : res;
    }
};
```


## 1 [904. 水果成篮 - 力扣（LeetCode）](https://leetcode.cn/problems/fruit-into-baskets/submissions/649617028/)

滑动窗口 + 哈希表
```cpp
class Solution 
{
public:
    int totalFruit(vector<int>& fruits) 
    {
        int res = 0;
        int size = fruits.size();
        unordered_map<int, int> map;
        int left = 0;
        for(int right = 0; right < size; right ++)
        {
            map[fruits[right]]++;
            while(map.size() >= 3)
            {
                //left++;
                map[fruits[left]]--;
                if(map[fruits[left]] == 0)
                {
                    map.erase(fruits[left]);
                }
                left++;
            }
            int len = right - left + 1;
            res = res > len ? res : len;
        }

        return res;
    }
};
```


	## 2 [76. 最小覆盖子串 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-window-substring/description/)

这个题目一开始理解错了，以为只要`t`中的每个字符都出现就可以了，没想到数量也要对上。
```cpp
class Solution 
{
public:
    string minWindow(string s, string t) 
    {
        //len(t) < len(s) return ""
        string res = "";
        int sizes = s.size();
        if(sizes < t.size()) return res;

        int left = 0;
        unordered_map<int, int> map;
        for(int it : t) //初始化哈希表
            map[*it] = 0;

        for(int right < 0; right < sizes; right++)
        {
            if(map.contains(s[right]))
                map[s[right]]++;
            
            //没有键值为0的时候
            while(std::all_of(m.begin(), m.end(),
                       [](const auto& kv) { return kv.second != 0; });)
            {
                res = s.substr(left, right - left + 1);

                
            }
        }
        
    }
};
```

依然是滑动窗口的思想，但是要维护两个哈希表。
AC1：
```cpp
class Solution {
public:
    unordered_map <char, int> ori, cnt;

    bool check() {
        for (const auto &p: ori) {
            if (cnt[p.first] < p.second) {
                return false;
            }
        }
        return true;
    }

    string minWindow(string s, string t) {
        for (const auto &c: t) {
            ++ori[c];
        }

        int l = 0, r = -1;
        int len = INT_MAX, ansL = -1, ansR = -1;

        while (r < int(s.size())) {
            if (ori.find(s[++r]) != ori.end()) {
                ++cnt[s[r]];
            }
            while (check() && l <= r) {
                if (r - l + 1 < len) {
                    len = r - l + 1;
                    ansL = l;
                }
                if (ori.find(s[l]) != ori.end()) {
                    --cnt[s[l]];
                }
                ++l;
            }
        }

        return ansL == -1 ? string() : s.substr(ansL, len);
    }
};
```

AC2：
```cpp
class Solution 
{
public:
    unordered_map<char, int> wnd, cnt; //维护两个哈希表

    bool check()
    {
        // 遍历需求表，确保需求表中每个字符在窗口里 都满足数量要求
        for(const auto &it : cnt)
        {
            if(wnd[it.first] < it.second)
                return false; //不满足，窗口应该扩大
        }
        return true; //窗口内的数量符合
    }

    string minWindow(string s, string t) 
    {
        //初始化cnt
        for(const auto &it : t)
            cnt[it]++;
        
        int l = 0, r = 0;
        int len = INT32_MAX, ansL = -1;
        
        while(r < s.size())
        {
            if(cnt.find(s[r]) != cnt.end())
                wnd[s[r]]++;

            while(check() && l <= r) //找到符合要求的窗口
            {
                if(r - l + 1 < len) //更新
                {
                    len = r - l + 1;
                    ansL = l;
                }
                if(cnt.find(s[l]) != cnt.end())
                    wnd[s[l]]--;
                
                l++;
            }

            r++;
        }

        return ansL == -1? "" : s.substr(ansL, len);
    }
};
```

关于AC2的 r 更新的位置；

1.只有在cnt中又目标字符在更新 r ,导致死循环。
```cpp
if(cnt.find(s[r]) != cnt.end())
    wnd[s[r]]++, r++;
```

2.r 更新的太早，后面的 while 区间和前面的区间并不等价。 
```cpp
if(cnt.find(s[r]) != cnt.end())
    wnd[s[r]]++;
r++;
```